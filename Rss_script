--[[
    ADVANCED GOALKEEPER AI v4.0 - PREDICTIVE SYSTEM
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—Ä–∞—Ç–∞—Ä—å —Å —Å–∏—Å—Ç–µ–º–æ–π –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
    –ü–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞—â–∏—â–µ–Ω –æ—Ç –∞–Ω—Ç–∏-—á–∏—Ç–æ–≤
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")

-- == –°–ò–°–¢–ï–ú–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò ==
local Security = {
    SessionID = HttpService:GenerateGUID(false),
    LastActivity = tick(),
    SuspicionLevel = 0,
    IsSafe = true,
    
    Methods = {
        "InputEmulation",
        "BehaviorPattern",
        "NetworkPrediction",
        "HumanEmulation"
    },
    
    Detectors = {
        "AntiCheat_A",
        "FairFight",
        "VAC_System",
        "GameGuard"
    }
}

-- == –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==
local Config = {
    -- –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    Enabled = false,
    Mode = "AUTO", -- AUTO, SEMI, MANUAL
    
    -- –§–∏–∑–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    JumpPower = {
        Low = 35,   -- –î–ª—è –Ω–∏–∑–∫–∏—Ö –º—è—á–µ–π (X)
        Normal = 50, -- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—Ä—ã–∂–æ–∫
        High = 65,  -- –î–ª—è –≤—ã—Å–æ–∫–∏—Ö –º—è—á–µ–π (Space)
        Side = 45   -- –ë–æ–∫–æ–≤—ã–µ –ø—Ä—ã–∂–∫–∏ (E/O)
    },
    
    -- –î–∏—Å—Ç–∞–Ω—Ü–∏–∏
    DetectionRange = {
        Close = 15,   -- –ë–ª–∏–∂–Ω—è—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
        Medium = 30,  -- –°—Ä–µ–¥–Ω—è—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
        Far = 50,     -- –î–∞–ª—å–Ω—è—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
        GoalLine = 25 -- –î–∏—Å—Ç–∞–Ω—Ü–∏—è –æ—Ç –ª–∏–Ω–∏–∏ –≤–æ—Ä–æ—Ç
    },
    
    -- –¢–∞–π–º–∏–Ω–≥–∏
    ReactionTime = {
        Min = 0.12, -- –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —Ä–µ–∞–∫—Ü–∏–∏
        Max = 0.25, -- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —Ä–µ–∞–∫—Ü–∏–∏
        HumanDelay = 0.05 -- –ò–º–∏—Ç–∞—Ü–∏—è –∑–∞–¥–µ—Ä–∂–∫–∏ —á–µ–ª–æ–≤–µ–∫–∞
    },
    
    -- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    Prediction = {
        Enabled = true,
        PingCompensation = 1.2,
        CurvePrediction = true,
        Accuracy = 0.85
    },
    
    -- –ó–∞—â–∏—Ç–∞
    Protection = {
        MaxSavesPerMinute = 10,
        CooldownAfterSave = 1.8,
        RandomMissChance = 0.03,
        JitterAmount = 0.15
    }
}

-- == –°–ò–°–¢–ï–ú–ê –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø ==
local PredictionSystem = {
    BallHistory = {},
    PlayerHistory = {},
    VelocityCache = {},
    
    -- –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
    Algorithms = {
        "LinearExtrapolation",
        "QuadraticPrediction",
        "NeuralApproximation",
        "VelocityBased"
    }
}

-- == –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Camera = workspace.CurrentCamera

-- –ò—Å—Ç–æ—Ä–∏—è –¥–≤–∏–∂–µ–Ω–∏–π
local lastPositions = {}
local lastVelocities = {}
local saveHistory = {}

-- == –û–ë–§–£–°–ö–ê–¶–ò–Ø –ö–û–î–ê ==
local function SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        Security.SuspicionLevel = Security.SuspicionLevel + 1
        return nil
    end
    return result
end

local function RandomDelay(min, max)
    local delay = math.random(min * 1000, max * 1000) / 1000
    task.wait(delay)
    return delay
end

-- == –°–ò–°–¢–ï–ú–ê –û–ë–ù–ê–†–£–ñ–ï–ù–ò–Ø –ú–Ø–ß–ê ==
local BallTracker = {
    LastBall = nil,
    BallInstances = {},
    DetectionMethods = {}
}

function BallTracker:FindBall()
    -- –ú–µ—Ç–æ–¥ 1: –ü–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏
    local ballNames = {
        "Ball", "SoccerBall", "Football", 
        "ball", "Sphere", "GameBall",
        "MainBall", "TPS_Ball"
    }
    
    for _, name in ipairs(ballNames) do
        local ball = Workspace:FindFirstChild(name)
        if ball and ball:IsA("BasePart") then
            return ball
        end
    end
    
    -- –ú–µ—Ç–æ–¥ 2: –ü–æ–∏—Å–∫ –ø–æ —Å–≤–æ–π—Å—Ç–≤–∞–º
    for _, obj in ipairs(Workspace:GetChildren()) do
        if obj:IsA("BasePart") and obj.Shape == Enum.PartType.Ball then
            return obj
        end
    end
    
    -- –ú–µ—Ç–æ–¥ 3: –ü–æ–∏—Å–∫ –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            local parentName = obj.Parent and obj.Parent.Name or ""
            if parentName:find("Ball") or parentName:find("Soccer") then
                return obj
            end
        end
    end
    
    return nil
end

function BallTracker:GetBallProperties(ball)
    if not ball then return nil end
    
    return {
        Position = ball.Position,
        Velocity = ball.VectorVelocity or ball.AssemblyLinearVelocity,
        Speed = ball.VectorVelocity and ball.VectorVelocity.Magnitude or 0,
        LastUpdate = tick()
    }
end

-- == –°–ò–°–¢–ï–ú–ê –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø –¢–†–ê–ï–ö–¢–û–†–ò–ò ==
function PredictionSystem:PredictTrajectory(ball, lookAheadTime)
    if not ball then return nil end
    
    local properties = BallTracker:GetBallProperties(ball)
    if not properties then return nil end
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
    table.insert(self.BallHistory, 1, {
        position = properties.Position,
        velocity = properties.Velocity,
        time = tick()
    })
    
    if #self.BallHistory > 10 then
        table.remove(self.BallHistory, 11)
    end
    
    -- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏–∏
    if #self.BallHistory >= 3 then
        local avgVelocity = Vector3.new(0, 0, 0)
        local count = 0
        
        for i = 1, math.min(3, #self.BallHistory) do
            local data = self.BallHistory[i]
            avgVelocity = avgVelocity + data.velocity
            count = count + 1
        end
        
        avgVelocity = avgVelocity / count
        
        -- –£—á–µ—Ç –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
        local gravity = Vector3.new(0, -workspace.Gravity * 0.5, 0)
        local predictedPos = properties.Position + 
                            (avgVelocity * lookAheadTime) + 
                            (gravity * (lookAheadTime ^ 2))
        
        return predictedPos, avgVelocity
    end
    
    -- –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    return properties.Position + (properties.Velocity * lookAheadTime), 
           properties.Velocity
end

-- == –°–ò–°–¢–ï–ú–ê –ü–†–ò–ù–Ø–¢–ò–Ø –†–ï–®–ï–ù–ò–ô ==
local DecisionSystem = {
    LastDecision = 0,
    DecisionHistory = {},
    Confidence = 0.0
}

function DecisionSystem:ShouldSave(ball, predictedPosition)
    if not ball or not predictedPosition then
        return false, 0
    end
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Ä–µ–∞–∫—Ü–∏–∏
    local timeSinceLastDecision = tick() - self.LastDecision
    if timeSinceLastDecision < 0.1 then
        return false, 0
    end
    
    -- –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –º—è—á–∞
    local properties = BallTracker:GetBallProperties(ball)
    if not properties or properties.Speed < 15 then
        return false, 0
    end
    
    -- –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –≤–æ—Ä–æ—Ç–∞–º
    local goalDirection = (HumanoidRootPart.Position - predictedPosition).Unit
    local ballDirection = properties.Velocity.Unit
    
    local dotProduct = goalDirection:Dot(ballDirection)
    local angleToGoal = math.deg(math.acos(math.clamp(dotProduct, -1, 1)))
    
    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
    local distance = (predictedPosition - HumanoidRootPart.Position).Magnitude
    local timeToReach = distance / math.max(properties.Speed, 1)
    
    local confidence = 0.0
    
    -- –§–∞–∫—Ç–æ—Ä—ã —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
    if angleToGoal < 45 then
        confidence = confidence + 0.4
    end
    
    if distance < Config.DetectionRange.Medium then
        confidence = confidence + 0.3
    end
    
    if properties.Speed > 25 then
        confidence = confidence + 0.3
    end
    
    -- –°–ª—É—á–∞–π–Ω—ã–π –ø—Ä–æ–º–∞—Ö –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞
    if math.random() < Config.Protection.RandomMissChance then
        confidence = confidence * 0.5
    end
    
    self.Confidence = confidence
    self.LastDecision = tick()
    
    return confidence > 0.7, confidence
end

function DecisionSystem:GetDiveType(ball, predictedPosition)
    if not ball or not predictedPosition then
        return "NONE", Vector3.new(0, 0, 0)
    end
    
    local properties = BallTracker:GetBallProperties(ball)
    local direction = (predictedPosition - HumanoidRootPart.Position).Unit
    
    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Å–æ—Ç—É –º—è—á–∞
    local heightDiff = predictedPosition.Y - HumanoidRootPart.Position.Y
    local horizontalDist = Vector3.new(predictedPosition.X, 0, predictedPosition.Z) -
                          Vector3.new(HumanoidRootPart.Position.X, 0, HumanoidRootPart.Position.Z)
    horizontalDist = horizontalDist.Magnitude
    
    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –Ω—ã—Ä–∫–∞
    if heightDiff > 5 then
        -- –í—ã—Å–æ–∫–∏–π –º—è—á
        if horizontalDist > 8 then
            return "SIDE_HIGH", direction * Config.JumpPower.High + Vector3.new(0, 10, 0)
        else
            return "HIGH", Vector3.new(0, Config.JumpPower.High, 0)
        end
    elseif heightDiff < -2 then
        -- –ù–∏–∑–∫–∏–π –º—è—á
        if horizontalDist > 6 then
            return "SIDE_LOW", direction * Config.JumpPower.Low
        else
            return "LOW", direction * Config.JumpPower.Low
        end
    else
        -- –°—Ä–µ–¥–Ω–∏–π –º—è—á
        if horizontalDist > 10 then
            return "SIDE", direction * Config.JumpPower.Side + Vector3.new(0, 5, 0)
        else
            return "NORMAL", direction * Config.JumpPower.Normal
        end
    end
end

-- == –°–ò–°–¢–ï–ú–ê –í–´–ü–û–õ–ù–ï–ù–ò–Ø –î–ï–ô–°–¢–í–ò–ô ==
local ActionSystem = {
    LastAction = 0,
    ActionQueue = {},
    KeyMap = {
        SPACE = Enum.KeyCode.Space,
        E = Enum.KeyCode.E,
        Q = Enum.KeyCode.Q,
        X = Enum.KeyCode.X,
        C = Enum.KeyCode.C
    }
}

function ActionSystem:PerformDive(diveType, forceVector)
    if tick() - self.LastAction < Config.Protection.CooldownAfterSave then
        return false
    end
    
    -- –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞
    local jitter = Vector3.new(
        (math.random() * 2 - 1) * Config.Protection.JitterAmount,
        (math.random() * 2 - 1) * Config.Protection.JitterAmount * 0.5,
        (math.random() * 2 - 1) * Config.Protection.JitterAmount
    )
    
    forceVector = forceVector + jitter
    
    -- –≠–º—É–ª—è—Ü–∏—è –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à
    local keysToPress = {}
    
    if diveType == "HIGH" then
        keysToPress = {self.KeyMap.SPACE}
    elseif diveType == "LOW" then
        keysToPress = {self.KeyMap.X}
    elseif diveType == "SIDE" then
        local sideKey = forceVector.X > 0 and self.KeyMap.E or self.KeyMap.Q
        keysToPress = {sideKey}
    elseif diveType == "SIDE_HIGH" then
        local sideKey = forceVector.X > 0 and self.KeyMap.E or self.KeyMap.Q
        keysToPress = {sideKey, self.KeyMap.SPACE}
    elseif diveType == "SIDE_LOW" then
        local sideKey = forceVector.X > 0 and self.KeyMap.E or self.KeyMap.Q
        keysToPress = {sideKey, self.KeyMap.X}
    end
    
    -- –ù–∞–∂–∏–º–∞–µ–º –∫–ª–∞–≤–∏—à–∏
    for _, key in ipairs(keysToPress) do
        VirtualInputManager:SendKeyEvent(true, key, false, nil)
        task.wait(0.02)
        VirtualInputManager:SendKeyEvent(false, key, false, nil)
    end
    
    -- –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–∑–∏—á–µ—Å–∫—É—é —Å–∏–ª—É
    if HumanoidRootPart and Character.PrimaryPart then
        HumanoidRootPart.Velocity = forceVector
        
        -- –ò–º–∏—Ç–∞—Ü–∏—è –ø—Ä—ã–∂–∫–∞
        if diveType:find("HIGH") or diveType == "NORMAL" then
            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
    
    self.LastAction = tick()
    table.insert(saveHistory, {
        time = tick(),
        type = diveType,
        confidence = DecisionSystem.Confidence
    })
    
    -- –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—É—é –∏—Å—Ç–æ—Ä–∏—é
    while #saveHistory > 0 and tick() - saveHistory[1].time > 60 do
        table.remove(saveHistory, 1)
    end
    
    return true
end

-- == –°–ò–°–¢–ï–ú–ê –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê ==
local MonitorSystem = {
    Stats = {
        TotalSaves = 0,
        SuccessfulSaves = 0,
        ReactionTimes = {},
        AverageReaction = 0
    },
    
    Alerts = {},
    Warnings = {}
}

function MonitorSystem:UpdateStats(success, reactionTime)
    self.Stats.TotalSaves = self.Stats.TotalSaves + 1
    
    if success then
        self.Stats.SuccessfulSaves = self.Stats.SuccessfulSaves + 1
    end
    
    table.insert(self.Stats.ReactionTimes, reactionTime)
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è —Ä–µ–∞–∫—Ü–∏–∏
    local sum = 0
    for _, rt in ipairs(self.Stats.ReactionTimes) do
        sum = sum + rt
    end
    self.Stats.AverageReaction = sum / #self.Stats.ReactionTimes
    
    -- –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
    if #self.Stats.ReactionTimes > 20 then
        table.remove(self.Stats.ReactionTimes, 1)
    end
end

function MonitorSystem:CheckSafety()
    local currentTime = tick()
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∞—Å—Ç–æ—Ç—ã —Å–µ–π–≤–æ–≤
    if #saveHistory >= Config.Protection.MaxSavesPerMinute then
        local oldestSave = saveHistory[1].time
        if currentTime - oldestSave < 60 then
            table.insert(self.Warnings, {
                time = currentTime,
                message = "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Å–µ–π–≤–æ–≤ –≤ –º–∏–Ω—É—Ç—É",
                level = "HIGH"
            })
            return false
        end
    end
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Ä–µ–∞–∫—Ü–∏–∏
    if self.Stats.AverageReaction < Config.ReactionTime.Min then
        Security.SuspicionLevel = Security.SuspicionLevel + 1
    end
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ä–æ–≤–Ω—è –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    if Security.SuspicionLevel > 5 then
        table.insert(self.Alerts, {
            time = currentTime,
            message = "–í—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏",
            action = "ENABLE_SAFE_MODE"
        })
        Config.Mode = "SAFE"
    end
    
    return Security.SuspicionLevel < 10
end

-- == –ò–ù–¢–ï–†–§–ï–ô–° ==
local Interface = {
    UI = nil,
    Elements = {},
    Visible = false
}

function Interface:Create()
    -- –°–æ–∑–¥–∞–µ–º –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GK_Assistant_" .. Security.SessionID:sub(1, 8)
    screenGui.Parent = Player:WaitForChild("PlayerGui")
    
    -- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 150)
    frame.Position = UDim2.new(0.01, 0, 0.3, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    frame.BackgroundTransparency = 0.3
    frame.Parent = screenGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    -- –ó–∞–≥–æ–ª–æ–≤–æ–∫
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.Text = "GK ASSISTANT v4.0"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.Parent = frame
    
    -- –°—Ç–∞—Ç—É—Å
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, 0, 0, 25)
    status.Position = UDim2.new(0, 0, 0, 30)
    status.Text = "Status: DISABLED"
    status.TextColor3 = Color3.fromRGB(255, 100, 100)
    status.BackgroundTransparency = 1
    status.Font = Enum.Font.Gotham
    status.TextSize = 14
    status.Parent = frame
    
    -- –ö–Ω–æ–ø–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0, 30)
    toggleBtn.Position = UDim2.new(0.05, 0, 0.4, 0)
    toggleBtn.Text = "ENABLE AI"
    toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
    toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.Parent = frame
    
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = toggleBtn
    
    -- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    local statsLabel = Instance.new("TextLabel")
    statsLabel.Size = UDim2.new(1, 0, 0, 60)
    statsLabel.Position = UDim2.new(0, 0, 0.65, 0)
    statsLabel.Text = "Saves: 0\nSuccess: 0%\nReaction: 0ms"
    statsLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    statsLabel.BackgroundTransparency = 1
    statsLabel.Font = Enum.Font.Gotham
    statsLabel.TextSize = 12
    statsLabel.TextXAlignment = Enum.TextXAlignment.Left
    statsLabel.TextYAlignment = Enum.TextYAlignment.Top
    statsLabel.Parent = frame
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
    self.Elements = {
        MainFrame = frame,
        StatusLabel = status,
        ToggleButton = toggleBtn,
        StatsLabel = statsLabel,
        ScreenGui = screenGui
    }
    
    -- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    toggleBtn.MouseButton1Click:Connect(function()
        Config.Enabled = not Config.Enabled
        if Config.Enabled then
            status.Text = "Status: ACTIVE"
            status.TextColor3 = Color3.fromRGB(100, 255, 100)
            toggleBtn.Text = "DISABLE AI"
            toggleBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
        else
            status.Text = "Status: DISABLED"
            status.TextColor3 = Color3.fromRGB(255, 100, 100)
            toggleBtn.Text = "ENABLE AI"
            toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
        end
    end)
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    spawn(function()
        while true do
            task.wait(1)
            if self.Elements.StatsLabel then
                local successRate = MonitorSystem.Stats.TotalSaves > 0 and 
                    (MonitorSystem.Stats.SuccessfulSaves / MonitorSystem.Stats.TotalSaves) * 100 or 0
                
                self.Elements.StatsLabel.Text = string.format(
                    "Saves: %d\nSuccess: %.1f%%\nReaction: %dms",
                    MonitorSystem.Stats.TotalSaves,
                    successRate,
                    math.floor(MonitorSystem.Stats.AverageReaction * 1000)
                )
            end
        end
    end)
end

-- == –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ ==
local MainLoop = {
    Running = true,
    LastUpdate = 0,
    UpdateInterval = 0.033 -- ~30 FPS
}

function MainLoop:Start()
    -- –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    Interface:Create()
    
    -- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏
    while self.Running do
        local startTime = tick()
        
        if Config.Enabled then
            -- –ù–∞—Ö–æ–¥–∏–º –º—è—á
            local ball = BallTracker:FindBall()
            
            if ball then
                -- –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é
                local lookAhead = Config.ReactionTime.Min + 
                                 (Player:GetNetworkPing() * Config.Prediction.PingCompensation)
                
                local predictedPos, predictedVel = PredictionSystem:PredictTrajectory(ball, lookAhead)
                
                -- –ü—Ä–∏–Ω–∏–º–∞–µ–º —Ä–µ—à–µ–Ω–∏–µ
                local shouldSave, confidence = DecisionSystem:ShouldSave(ball, predictedPos)
                
                if shouldSave and MonitorSystem:CheckSafety() then
                    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –Ω—ã—Ä–∫–∞
                    local diveType, forceVector = DecisionSystem:GetDiveType(ball, predictedPos)
                    
                    if diveType ~= "NONE" then
                        -- –í—ã–ø–æ–ª–Ω—è–µ–º –Ω—ã—Ä–æ–∫
                        local success = ActionSystem:PerformDive(diveType, forceVector)
                        
                        -- –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                        local reactionTime = tick() - startTime
                        MonitorSystem:UpdateStats(success, reactionTime)
                        
                        -- –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ —Å–µ–π–≤–∞
                        RandomDelay(0.1, 0.3)
                    end
                end
            end
        end
        
        -- –ö–æ–Ω—Ç—Ä–æ–ª—å —á–∞—Å—Ç–æ—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        local elapsed = tick() - startTime
        local waitTime = math.max(0.001, self.UpdateInterval - elapsed)
        task.wait(waitTime)
        
        self.LastUpdate = tick()
    end
end

-- == –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –ó–ê–ü–£–°–ö ==
local function Initialize()
    print("Initializing Goalkeeper AI v4.0...")
    print("Session ID:", Security.SessionID)
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
    local isEnvironmentSafe = MonitorSystem:CheckSafety()
    
    if not isEnvironmentSafe then
        warn("‚ö†Ô∏è WARNING: Environment check failed!")
        Config.Mode = "SAFE"
    end
    
    -- –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
    spawn(function()
        MainLoop:Start()
    end)
    
    print("‚úÖ Goalkeeper AI initialized successfully")
    print("üìä Mode:", Config.Mode)
    print("üõ°Ô∏è Security Level:", Security.SuspicionLevel)
end

-- –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
Initialize()

-- –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
game:BindToClose(function()
    MainLoop.Running = false
    if Interface.Elements.ScreenGui then
        Interface.Elements.ScreenGui:Destroy()
    end
    print("üö™ Goalkeeper AI shutdown complete")
end)
