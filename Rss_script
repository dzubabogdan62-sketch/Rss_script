-- ü•Ö –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ó–ê–©–ò–¢–ê –í–†–ê–¢–ê–†–Ø - –ù–ï–ü–†–û–ë–ò–í–ê–ï–ú–´–ô –©–ò–¢
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

local Settings = {
    Enabled = true,
    Size = 60,
    Power = 200,
    MaxBallSpeed = 500, -- –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –º—è—á–∞
    CheckDistance = 80, -- –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    AntiGlitch = true -- –ó–∞—â–∏—Ç–∞ –æ—Ç –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è
}

local shield = Instance.new("Part")
shield.Name = "GateShield"
shield.Shape = Enum.PartType.Ball
shield.Size = Vector3.new(Settings.Size, Settings.Size, Settings.Size)
shield.Material = Enum.Material.ForceField
shield.CanCollide = false
shield.Anchored = true
shield.Transparency = 0.2
shield.Color = Color3.fromRGB(255, 0, 0)
shield.Parent = workspace

-- –ö–ù–û–ü–ö–ê
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game.CoreGui
local btn = Instance.new("TextButton")
btn.Parent = ScreenGui
btn.Size = UDim2.fromOffset(60, 60)
btn.Position = UDim2.new(0, 10, 0.5, -30)
btn.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
btn.TextColor3 = Color3.new(1,1,1)
btn.Text = "üõ°Ô∏è"
btn.TextSize = 30
btn.Font = Enum.Font.GothamBold
Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 15)

local active = true
btn.MouseButton1Click:Connect(function()
    active = not active
    btn.BackgroundColor3 = active and Color3.fromRGB(255, 50, 50) or Color3.fromRGB(100, 100, 100)
end)

-- –¢–ê–ë–õ–ò–¶–ê –î–õ–Ø –û–¢–°–õ–ï–ñ–ò–í–ê–ù–ò–Ø –ú–Ø–ß–ï–ô
local trackedBalls = {}

-- –§–£–ù–ö–¶–ò–Ø –ü–†–û–í–ï–†–ö–ò –ú–Ø–ß–ê
local function isBall(obj)
    return obj:IsA("BasePart") and (
        obj.Name == "ball" or 
        obj.Name == "TouchBall" or 
        obj.Name == "SoccerBall" or
        obj.Name == "Football" or
        obj:FindFirstChild("BallScript")
    )
end

-- –§–£–ù–ö–¶–ò–Ø –û–ë–†–ê–ë–û–¢–ö–ò –ú–Ø–ß–ê
local function processBall(ball, shieldPos, shieldRadius)
    if not ball or not ball.Parent then return end
    
    -- –ü–†–û–í–ï–†–ö–ê 1: –ë–∞–∑–æ–≤–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
    local ballPos = ball.Position
    local distance = (ballPos - shieldPos).Magnitude
    local effectiveRadius = shieldRadius + 10
    
    if distance > effectiveRadius then 
        trackedBalls[ball] = nil
        return 
    end
    
    -- –ü–†–û–í–ï–†–ö–ê 2: –°–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è
    local velocity = ball.AssemblyLinearVelocity
    local speed = velocity.Magnitude
    
    -- –ü–†–û–í–ï–†–ö–ê 3: –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –∫ —â–∏—Ç—É
    local toShield = (shieldPos - ballPos).Unit
    local velocityDir = velocity.Unit
    local approaching = velocityDir:Dot(toShield) > -0.3 -- –î–≤–∏–∂–µ—Ç—Å—è –∫ —â–∏—Ç—É –∏–ª–∏ —Ä—è–¥–æ–º
    
    -- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –û–¢–°–õ–ï–ñ–ò–í–ê–ù–ò–Ø
    if not trackedBalls[ball] then
        trackedBalls[ball] = {
            lastPos = ballPos,
            lastTime = tick(),
            bounceCount = 0
        }
    end
    
    local trackData = trackedBalls[ball]
    local currentTime = tick()
    local deltaTime = currentTime - trackData.lastTime
    
    -- –ü–†–û–í–ï–†–ö–ê 4: –†–µ–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å —á–µ—Ä–µ–∑ –ø–æ–∑–∏—Ü–∏—é
    local actualSpeed = 0
    if deltaTime > 0 then
        actualSpeed = (ballPos - trackData.lastPos).Magnitude / deltaTime
    end
    
    -- –ü–†–û–í–ï–†–ö–ê 5: –ú—è—á –≤–Ω—É—Ç—Ä–∏ —â–∏—Ç–∞ –∏–ª–∏ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ
    local isInside = distance <= effectiveRadius
    
    -- –ü–†–û–í–ï–†–ö–ê 6: –ú—è—á –¥–≤–∏–∂–µ—Ç—Å—è —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Ö–æ–¥–∏—Ç —Å–∫–≤–æ–∑—å
    local isTeleporting = actualSpeed > 200 and deltaTime < 0.1
    
    -- –£–°–õ–û–í–ò–Ø –î–õ–Ø –û–¢–°–ö–û–ö–ê
    local shouldBounce = isInside or isTeleporting or (approaching and distance < effectiveRadius * 1.2)
    
    if shouldBounce and trackData.bounceCount < 3 then
        -- –í–ï–ö–¢–û–† –û–¢–°–ö–û–ö–ê
        local surfaceNormal = (ballPos - shieldPos).Unit
        
        -- –ö–û–†–†–ï–ö–¢–ò–†–û–í–ö–ê –î–õ–Ø –ú–Ø–ß–ê –í –†–£–ö–ê–•
        if speed < 5 then
            -- –ú—è—á –ø–æ—á—Ç–∏ —Å—Ç–æ–∏—Ç (–≤–æ–∑–º–æ–∂–Ω–æ –≤ —Ä—É–∫–∞—Ö) - –º—è–≥–∫–∏–π –æ—Ç—Å–∫–æ–∫ –≤–ø–µ—Ä–µ–¥
            ball.AssemblyLinearVelocity = surfaceNormal * 40 + Vector3.new(0, 20, 0)
        else
            -- –£–°–ò–õ–ï–ù–ù–´–ô –û–¢–°–ö–û–ö
            local bounceForce = math.clamp(Settings.Power + speed * 0.5, Settings.Power, Settings.MaxBallSpeed)
            ball.AssemblyLinearVelocity = surfaceNormal * bounceForce + Vector3.new(0, 25, 0)
        end
        
        -- –í–†–ê–©–ï–ù–ò–ï
        ball.AssemblyAngularVelocity = Vector3.new(
            math.random(-60, 60),
            math.random(-60, 60),
            math.random(-60, 60)
        )
        
        -- –ê–ù–¢–ò–ì–õ–ò–¢–ß: –¢–µ–ª–µ–ø–æ—Ä—Ç –º—è—á–∞ –ó–ê –ø—Ä–µ–¥–µ–ª—ã —â–∏—Ç–∞
        if Settings.AntiGlitch and distance < shieldRadius * 0.8 then
            ball.CFrame = CFrame.new(shieldPos + surfaceNormal * (shieldRadius + 5))
        end
        
        trackData.bounceCount = trackData.bounceCount + 1
        trackData.lastTime = currentTime
        
        -- –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
        shield.Color = Color3.fromRGB(0, 255, 0)
        task.wait(0.05)
        shield.Color = Color3.fromRGB(255, 0, 0)
    end
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
    trackData.lastPos = ballPos
    trackData.lastTime = currentTime
    
    -- –°–±—Ä–æ—Å —Å—á—ë—Ç—á–∏–∫–∞ –æ—Ç—Å–∫–æ–∫–æ–≤ —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
    if currentTime - trackData.lastTime > 0.5 then
        trackData.bounceCount = 0
    end
end

-- –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ
RunService.Heartbeat:Connect(function()
    if not active then 
        shield.Transparency = 1
        return 
    end
    
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChild("Humanoid")
    
    if not root or not humanoid then return end
    
    -- –°–¢–ê–ë–ò–õ–ò–ó–ê–¶–ò–Ø –í–†–ê–¢–ê–†–Ø (–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –¥—ë—Ä–≥–∞–Ω–∏–π)
    if humanoid.PlatformStand == true then
        humanoid.PlatformStand = false
    end
    root.AssemblyLinearVelocity = Vector3.new(
        root.AssemblyLinearVelocity.X,
        math.clamp(root.AssemblyLinearVelocity.Y, -50, 50),
        root.AssemblyLinearVelocity.Z
    )
    
    -- –ü–û–ó–ò–¶–ò–Ø –©–ò–¢–ê
    shield.CFrame = root.CFrame * CFrame.new(0, 0, -Settings.Size/4)
    shield.Size = Vector3.new(Settings.Size, Settings.Size, Settings.Size)
    shield.Transparency = 0.2
    
    local shieldPos = shield.Position
    local shieldRadius = Settings.Size / 2
    
    -- –°–ö–ê–ù–ò–†–û–í–ê–ù–ò–ï –ú–Ø–ß–ï–ô –í WORKSPACE
    for _, obj in pairs(workspace:GetChildren()) do
        if isBall(obj) then
            processBall(obj, shieldPos, shieldRadius)
        end
    end
    
    -- –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –í –ë–û–õ–¨–®–û–ú –†–ê–î–ò–£–°–ï
    local region = Region3.new(
        shieldPos - Vector3.new(Settings.CheckDistance, Settings.CheckDistance, Settings.CheckDistance),
        shieldPos + Vector3.new(Settings.CheckDistance, Settings.CheckDistance, Settings.CheckDistance)
    )
    region = region:ExpandToGrid(4)
    
    for _, part in pairs(workspace:FindPartsInRegion3(region, nil, 100)) do
        if isBall(part) then
            processBall(part, shieldPos, shieldRadius)
        end
    end
end)

-- –û–ß–ò–°–¢–ö–ê –ü–†–ò –í–´–•–û–î–ï
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == lp then
        shield:Destroy()
        ScreenGui:Destroy()
    end
end)

print("‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è –∑–∞—â–∏—Ç–∞ –≤—Ä–∞—Ç–∞—Ä—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!")
print("- –ê–Ω—Ç–∏–≥–ª–∏—Ç—á —Å–∏—Å—Ç–µ–º–∞")
print("- –°—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞")
print("- –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –º—è—á–∞")
print("- –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –Ω–∞ –ª—é–±–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏")
