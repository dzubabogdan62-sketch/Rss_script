local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local ReachDistance = 1
local IsReachEnabled = false
local IsVisualizerEnabled = false
local HitboxSize = Vector3.new(10, 10, 10)
local ReachConnection = nil
local Ball = nil
local RSSHitbox = nil
getgenv().InfiniteStaminaEnabled = false

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end

    RSSHitbox = Instance.new("BoxHandleAdornment")
    RSSHitbox.Name = "RSSHitbox"
    RSSHitbox.AlwaysOnTop = false
    RSSHitbox.ZIndex = 10
    RSSHitbox.Color3 = Color3.fromRGB(0, 255, 0)
    RSSHitbox.Transparency = 1
    RSSHitbox.Size = HitboxSize
    RSSHitbox.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    RSSHitbox.Parent = Workspace.Terrain

    local Glow = Instance.new("BoxHandleAdornment")
    Glow.Name = "Glow"
    Glow.AlwaysOnTop = true
    Glow.ZIndex = 0
    Glow.Color3 = Color3.fromRGB(0, 255, 100)
    Glow.Transparency = 1
    Glow.Size = HitboxSize * 1
    Glow.Parent = RSSHitbox
end

local function UpdateHitbox()
    if not RSSHitbox then return end
    
    RSSHitbox.Size = HitboxSize
    local Glow = RSSHitbox:FindFirstChild("Glow")
    if Glow then 
        Glow.Size = HitboxSize * 1
    end

    local shouldShow = IsReachEnabled and IsVisualizerEnabled
    
    RSSHitbox.Transparency = shouldShow and 1 or 1
    if Glow then 
        Glow.Transparency = shouldShow and 0.7 or 1
    end
end

local function GetRoot() 
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function FindBall()
    local b = Workspace:FindFirstChild("ball")
    if b and b:IsA("BasePart") then return b end
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end

    RSSHitbox.Adornee = root
    local Glow = RSSHitbox:FindFirstChild("Glow")
    if Glow then Glow.Adornee = root end

    local ball = FindBall()
    if not ball then return end

    local effectiveReach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) / 2

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        for _, part in LocalPlayer.Character:GetChildren() do
            if part:IsA("BasePart") then
                firetouchinterest(part, ball, 0)
                task.wait()
                firetouchinterest(part, ball, 1)
            end
        end
    end
end

local function EnableReach()
    if ReachConnection then return end
    IsReachEnabled = true
    UpdateHitbox()
    ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConnection then 
        ReachConnection:Disconnect() 
        ReachConnection = nil 
    end
    IsReachEnabled = false
    UpdateHitbox()
end

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value

        if InfiniteStaminaEnabled and speeds then
            speeds.Walk.Value = speeds.Run.Value
        end
    end)
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
end)

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA",
    Icon = "rbxassetid://106211849494703",
    Author = "Made By VETA",
    Folder = "RSSVETA",
})

local MainTab = Window:Tab({
    Title = "GK & Player Reach",
    Icon = "target",
})

local MainSection = MainTab:Section({
    Title = "Both Reach (Pretty Bad At GK)"
})

MainSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = function(v)
        if v then
            EnableReach()
        else
            DisableReach()
        end
    end
})

MainSection:Toggle({
    Title = "Show Hitbox",
    Default = false,
    Callback = function(v)
        IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "Hitbox Size (X/Y/Z)"
})

SizeSection:Slider({
    Title = "Size X",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(v, HitboxSize.Y, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Y",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, v, HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "Size Z",
    Step = 1,
    Value = {
        Min = 1,
        Max = 50,
        Default = 10,
    },
    Callback = function(v)
        HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, v)
        UpdateHitbox()
    end
})

local GkTab = Window:Tab({
    Title = "GK Features",
    Icon = "rbxassetid://10734950020"
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local function isInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local AutoPickSection = GkTab:Section({
    Title = "Auto Pick GK"
})

AutoPickSection:Dropdown({
    Title = "Choose Team",
    Desc = "USE THIS WHEN NO GK IN TEAM",
    Values = {"Home GK", "Away GK"},
    Value = nil,
    Multi = false,
    AllowNone = true,
    Callback = function(option)
        if not option or option == "" then
            return
        end
        
        if not isInFansTeam() then
            WindUI:Notify({
                Title = "Error",
                Icon = "ban",
                Content = "You must be in Fans/No Team to use this feature!",
                Duration = 5,
            })
            return
        end
        
        if option == "Home GK" then
            local args = {
                BrickColor.new(23),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        elseif option == "Away GK" then
            local args = {
                BrickColor.new(141),
                "Goalie"
            }
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        end
    end
})

local DiveSection = GkTab:Section({
        Title = "Auto Dive"
    })

-- ===== AUTO GK V2 FUNCTIONS =====
local GKV2_MIN_BALL_SPEED = 8
local GKV2_NEAR_GOAL_DISTANCE_4v4 = 25
local GKV2_NEAR_GOAL_DISTANCE_7v7 = 40
local GKV2_DIVE_COOLDOWN = 0.6
local GKV2_ENABLED = false
local GKV2_CONNECTION = nil
local GK_GOAL_Z_POSITION = -150 -- Approximate goal position

local function isBallHeadingToGoal(ball, playerPos)
    if not ball or not playerPos then return false end
    
    local ballVel = ball.AssemblyLinearVelocity
    local ballSpeed = ballVel.Magnitude
    
    if ballSpeed < GKV2_MIN_BALL_SPEED then return false end
    
    -- Check if ball is moving towards the goal (negative Z direction for defending goal)
    local ballToGoal = (Vector3.new(playerPos.X, playerPos.Y, GK_GOAL_Z_POSITION) - ball.Position)
    local dotProduct = ballVel:Dot(ballToGoal.Unit)
    
    return dotProduct > 2 -- Ball velocity component towards goal
end

local function shouldDive(ball, playerPos)
    if not ball or not playerPos then return false end
    
    local velocity = ball.AssemblyLinearVelocity
    local speed = velocity.Magnitude
    
    if speed < GKV2_MIN_BALL_SPEED then return false end
    if not isBallHeadingToGoal(ball, playerPos) then return false end
    
    local distance = (ball.Position - playerPos).Magnitude
    return distance <= 35 and distance > 0
end

local function isPlayerNearGoal(playerPos)
    if not playerPos then return false end
    
    local goalPos = Vector3.new(playerPos.X, 5, GK_GOAL_Z_POSITION)
    local distance = (playerPos - goalPos).Magnitude
    
    -- Check game mode based on distance to center
    local centerDistance = math.abs(playerPos.X)
    local gameMode = centerDistance < 30 and "4v4" or "7v7"
    
    if gameMode == "7v7" then
        return distance <= GKV2_NEAR_GOAL_DISTANCE_7v7
    else
        return distance <= GKV2_NEAR_GOAL_DISTANCE_4v4
    end
end

local function calculateDiveDirection(ball, playerCFrame)
    if not ball or not playerCFrame then return "Space" end
    
    local ballPos = ball.Position
    local ballVel = ball.AssemblyLinearVelocity
    
    -- Predict ball position with higher prediction time for accuracy
    local predictedPos = ballPos + ballVel * 0.2
    local localBallPos = playerCFrame:PointToObjectSpace(predictedPos)
    
    local dirX = localBallPos.X
    local dirY = localBallPos.Y
    local dirZ = localBallPos.Z
    
    -- Determine jump type based on predicted ball position
    -- High ball (above head)
    if dirY > 4 then
        if dirX < -3 then
            return "UpperLeft"  -- E + Space equivalent
        elseif dirX > 3 then
            return "UpperRight"  -- Q + Space equivalent
        else
            return "Upper"  -- Space + X equivalent
        end
    -- Low ball (below waist)
    elseif dirY < -1 then
        return "Low"  -- X equivalent
    -- Medium height (normal saves)
    else
        if dirX < -3 then
            return "Left"  -- Q equivalent
        elseif dirX > 3 then
            return "Right"  -- E equivalent
        else
            return "Center"  -- Space equivalent
        end
    end
end

local function doDive(direction, leftDiveButton, rightDiveButton, jumpButton)
    if not leftDiveButton or not rightDiveButton or not jumpButton then return end
    
    local function clickButton(btn)
        if typeof(getconnections) == "function" and btn.MouseButton1Click then
            local connections = getconnections(btn.MouseButton1Click)
            if connections and #connections > 0 then
                for _, conn in ipairs(connections) do
                    conn:Fire()
                end
                return
            end
        end
        btn.MouseButton1Click:Fire()
    end
    
    if direction == "Left" then
        clickButton(leftDiveButton)
    elseif direction == "Right" then
        clickButton(rightDiveButton)
    elseif direction == "UpperLeft" then
        clickButton(leftDiveButton)
        task.wait(0.05)
        clickButton(jumpButton)
    elseif direction == "UpperRight" then
        clickButton(rightDiveButton)
        task.wait(0.05)
        clickButton(jumpButton)
    elseif direction == "Low" then
        -- Hold button pattern for low dive
        clickButton(jumpButton)
    elseif direction == "Upper" or direction == "Center" then
        clickButton(jumpButton)
    end
end

-- ===== AUTO GK V2 TOGGLE =====
local GKV2Section = GkTab:Section({
    Title = "Auto GK V2 (Advanced)"
})

local GKV2Toggle = GKV2Section:Toggle({
    Title = "Enable Auto GK V2",
    Desc = "Advanced GK with smart dive direction prediction",
    Default = false,
    Callback = function(enabled)
        GKV2_ENABLED = enabled
        
        if GKV2_CONNECTION then
            GKV2_CONNECTION:Disconnect()
            GKV2_CONNECTION = nil
        end
        
        if not enabled then return end
        
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        
        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        local mobileCTRL = playerGui:WaitForChild("MobileCTRL")
        local touchControlFrame = mobileCTRL:WaitForChild("TouchControlFrame")
        local jumpButton = touchControlFrame:WaitForChild("JumpButton")
        local leftDiveButton = jumpButton:WaitForChild("LeftDive")
        local rightDiveButton = jumpButton:WaitForChild("RightDive")
        
        local lastDiveTime = 0
        
        GKV2_CONNECTION = RunService.Heartbeat:Connect(function()
            if not GKV2_ENABLED then return end
            
            local ball = Workspace:FindFirstChild("ball") or Workspace:FindFirstChild("TPS") or Workspace:FindFirstChild("PSoccerBall")
            if not ball then return end
            
            local playerPos = HumanoidRootPart.Position
            if not playerPos then return end
            
            -- Check if should dive
            if not shouldDive(ball, playerPos) then return end
            
            -- Check if near goal
            if not isPlayerNearGoal(playerPos) then return end
            
            -- Check cooldown
            local currentTime = tick()
            if currentTime - lastDiveTime < GKV2_DIVE_COOLDOWN then return end
            
            -- Calculate and perform dive
            local diveDir = calculateDiveDirection(ball, HumanoidRootPart.CFrame)
            doDive(diveDir, leftDiveButton, rightDiveButton, jumpButton)
            lastDiveTime = currentTime
        end)
        
        WindUI:Notify({
            Title = "Auto GK V2",
            Icon = "check",
            Content = "Auto GK V2 Enabled",
            Duration = 3,
        })
    end
})

GKV2Section:Slider({
    Title = "Min Ball Speed",
    Step = 0.5,
    Value = {
        Min = 3,
        Max = 20,
        Default = 8,
    },
    Callback = function(v)
        GKV2_MIN_BALL_SPEED = v
    end
})

GKV2Section:Slider({
    Title = "Near Goal Distance 4v4",
    Step = 1,
    Value = {
        Min = 15,
        Max = 40,
        Default = 25,
    },
    Callback = function(v)
        GKV2_NEAR_GOAL_DISTANCE_4v4 = v
    end
})

GKV2Section:Slider({
    Title = "Near Goal Distance 7v7",
    Step = 1,
    Value = {
        Min = 25,
        Max = 60,
        Default = 40,
    },
    Callback = function(v)
        GKV2_NEAR_GOAL_DISTANCE_7v7 = v
    end
})

GKV2Section:Slider({
    Title = "Dive Cooldown",
    Step = 0.1,
    Value = {
        Min = 0.3,
        Max = 1.5,
        Default = 0.6,
    },
    Callback = function(v)
        GKV2_DIVE_COOLDOWN = v
    end
})

local DiveToggle = DiveSection:Toggle({
    Title = "Auto Dive [BETA|MIGHT BUG]",
    Desc = "USE THIS WHEN BEING GK",
    Default = false,
    Callback = function(enabled)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")

        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

        if not getgenv().AutoDiveConnection then
            getgenv().AutoDiveConnection = nil
        end
        
        if getgenv().AutoDiveConnection then
            getgenv().AutoDiveConnection:Disconnect()
            getgenv().AutoDiveConnection = nil
        end
        
        if not enabled then
            return
        end

        local DIVE_DISTANCE = 10.3
        local DIVE_COOLDOWN = 0.7
        local SMART_DIVE = true

        local lastDiveTime = 0
        local leftDiveButton = nil
        local rightDiveButton = nil

        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        local mobileCTRL = playerGui:WaitForChild("MobileCTRL")
        local touchControlFrame = mobileCTRL:WaitForChild("TouchControlFrame")
        local jumpButton = touchControlFrame:WaitForChild("JumpButton")
        leftDiveButton = jumpButton:WaitForChild("LeftDive")
        rightDiveButton = jumpButton:WaitForChild("RightDive")

        local function clickLeftDive()
            local connections = getconnections(leftDiveButton.MouseButton1Click)
            if connections and #connections > 0 then
                connections[1]:Fire()
            else
                leftDiveButton.MouseButton1Click:Fire()
            end
        end

        local function clickRightDive()
            local connections = getconnections(rightDiveButton.MouseButton1Click)
            if connections and #connections > 0 then
                connections[1]:Fire()
            else
                rightDiveButton.MouseButton1Click:Fire()
            end
        end

        local function autoDive(ballPosition)
            local currentTime = tick()
            
            if currentTime - lastDiveTime < DIVE_COOLDOWN then
                return
            end
            
            if SMART_DIVE then
                local playerCFrame = HumanoidRootPart.CFrame
                local localBallPos = playerCFrame:PointToObjectSpace(ballPosition)
                
                if localBallPos.X < 0 then
                    clickLeftDive()
                else
                    clickRightDive()
                end
            else
                clickLeftDive()
            end
            
            lastDiveTime = currentTime
        end

        getgenv().AutoDiveConnection = RunService.Heartbeat:Connect(function()
            local ball = workspace:FindFirstChild("ball")
            if not ball then return end
            
            local ballPos = ball.Position
            if not ballPos then return end
            
            local distance = (HumanoidRootPart.Position - ballPos).Magnitude
            
            if distance <= DIVE_DISTANCE then
                autoDive(ballPos)
            end
        end)
    end
})

local StaminaTab = Window:Tab({
    Title = "Infinite Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "Infinite Stamina"
})

StaminaSection:Toggle({
    Title = "Enable Infinite Stamina",
    Default = false,
    Callback = function(v)
        getgenv().InfiniteStaminaEnabled = v
        if speeds then
            speeds.Walk.Value = v and speeds.Run.Value or defaultWalk
        end
    end
})

local PredictTab = Window:Tab({
    Title = "Ball Predictor",
    Icon = "circle",
})

local PredictSection = PredictTab:Section({
    Title = "Ball Predictor"
})

local predictionConnection = nil
local curveFolder = nil

PredictSection:Toggle({
    Title = "Enable Ball Predictor",
    Default = false,
    Callback = function(Value)
        if Value then
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local Workspace = game:GetService("Workspace")

            local config = {
                gravity = 196.2,
                bounceDamping = 0.68,
                groundHeight = 0,
                minBounceVelocity = 8,
                airResistance = 0.99,
                frictionCoefficient = 0.85,
                spinDecay = 0.95,
                magnusCoefficient = 0.00015,
                terminalVelocity = 200,
                rollingResistance = 0.92,
                
                segmentCount = 25,
                segmentSize = Vector3.new(0.3, 0.3, 2),
                segmentTransparency = 0.2,
                maxPredictionTime = 10,
                minVelocityThreshold = 3,
                simulationTimestep = 0.033,
                maxSimulationPoints = 80,
                updateRate = 3,
                
                colorCurve = Color3.fromRGB(0, 255, 0),
                colorLanding = Color3.fromRGB(0, 255, 0),
            }

            local vector3Zero = Vector3.zero
            local vector3Up = Vector3.new(0, 1, 0)
            local gravityVector = Vector3.new(0, -config.gravity, 0)

            local cachedBall = nil
            local lastBallCheck = 0
            local ballCheckInterval = 1

            local function getBall()
                local now = tick()
                if cachedBall and cachedBall.Parent and now - lastBallCheck < ballCheckInterval then
                    return cachedBall
                end
                
                lastBallCheck = now
                cachedBall = Workspace:FindFirstChild("TPS", true) 
                    or Workspace:FindFirstChild("PSoccerBall", true)
                    or Workspace:FindFirstChild("ball", true)
                
                return cachedBall
            end

            curveFolder = Instance.new("Folder")
            curveFolder.Name = "BallPredictionCurve"
            curveFolder.Parent = workspace

            local segments = table.create(config.segmentCount)
            for i = 1, config.segmentCount do
                local segment = Instance.new("Part")
                segment.Name = "Segment_" .. i
                segment.Anchored = true
                segment.CanCollide = false
                segment.CastShadow = false
                segment.Material = Enum.Material.Neon
                segment.Transparency = config.segmentTransparency
                segment.Size = config.segmentSize
                segment.Color = config.colorCurve
                segment.Parent = curveFolder
                segments[i] = segment
            end

            local landingMarker = Instance.new("Part")
            landingMarker.Name = "LandingMarker"
            landingMarker.Anchored = true
            landingMarker.CanCollide = false
            landingMarker.CastShadow = false
            landingMarker.Material = Enum.Material.Neon
            landingMarker.Color = config.colorLanding
            landingMarker.Transparency = 0.4
            landingMarker.Size = Vector3.new(4, 0.2, 4)
            landingMarker.Shape = Enum.PartType.Cylinder
            landingMarker.Parent = curveFolder

            local landingRing = Instance.new("Part")
            landingRing.Name = "LandingRing"
            landingRing.Anchored = true
            landingRing.CanCollide = false
            landingRing.CastShadow = false
            landingRing.Material = Enum.Material.Neon
            landingRing.Color = config.colorLanding
            landingRing.Transparency = 0.6
            landingRing.Size = Vector3.new(6, 0.1, 6)
            landingRing.Shape = Enum.PartType.Cylinder
            landingRing.Parent = curveFolder

            local function simulateTrajectory(startPos, startVel)
                local points = table.create(config.maxSimulationPoints)
                local dt = config.simulationTimestep
                local maxTime = config.maxPredictionTime
                local gravityDt = gravityVector * dt
                local airResistance = config.airResistance ^ dt
                
                local pos = startPos
                local vel = startVel
                local time = 0
                local bounceCount = 0
                local pointCount = 0
                
                while time < maxTime and bounceCount < 8 and pointCount < config.maxSimulationPoints do
                    time = time + dt
                    pointCount = pointCount + 1
                    
                    vel = (vel + gravityDt) * airResistance
                    
                    if vel.Y < -config.terminalVelocity then
                        vel = Vector3.new(vel.X, -config.terminalVelocity, vel.Z)
                    end
                    
                    pos = pos + vel * dt
                    
                    points[pointCount] = {pos, vel, vel.Magnitude}
                    
                    if pos.Y <= config.groundHeight and vel.Y < 0 then
                        pos = Vector3.new(pos.X, config.groundHeight, pos.Z)
                        
                        local bounceVelY = -vel.Y * config.bounceDamping
                        vel = Vector3.new(
                            vel.X * config.frictionCoefficient,
                            bounceVelY,
                            vel.Z * config.frictionCoefficient
                        )
                        
                        bounceCount = bounceCount + 1
                        
                        if vel.Magnitude < config.minBounceVelocity then
                            points[pointCount] = {pos, vector3Zero, 0}
                            break
                        end
                    end
                    
                    if pos.Y < -500 or vel.Magnitude < 0.3 then
                        break
                    end
                end
                
                return points, pointCount
            end

            local function findFirstLanding(points, count)
                for i = 2, count do
                    local curr = points[i]
                    local prev = points[i-1]
                    local currPos, currVel = curr[1], curr[2]
                    local prevPos, prevVel = prev[1], prev[2]
                    
                    if currPos.Y <= config.groundHeight + 0.5 and 
                       prevPos.Y > config.groundHeight + 0.5 and
                       currVel.Y < 0 then
                        
                        local t = (config.groundHeight - prevPos.Y) / (currPos.Y - prevPos.Y)
                        t = math.clamp(t, 0, 1)
                        
                        return prevPos:Lerp(currPos, t), prevVel:Lerp(currVel, t)
                    end
                end
                return nil, nil
            end

            local frameCounter = 0
            local lastTrajectoryPoints = nil
            local lastPointCount = 0
            local lastLandingPos = nil
            local lastLandingVel = nil

            predictionConnection = RunService.Heartbeat:Connect(function()
                frameCounter = frameCounter + 1
                
                if frameCounter % config.updateRate ~= 0 then
                    return
                end
                
                local ball = getBall()
                if not ball then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local velocity = ball.AssemblyLinearVelocity
                local speed = velocity.Magnitude
                
                if speed < config.minVelocityThreshold then
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                    return
                end
                
                local trajectoryPoints, pointCount = simulateTrajectory(ball.Position, velocity)
                lastTrajectoryPoints = trajectoryPoints
                lastPointCount = pointCount
                
                if pointCount > 1 then
                    local segmentStep = (pointCount - 1) / (config.segmentCount - 1)
                    
                    for i = 1, config.segmentCount do
                        local pointIndex = math.floor((i - 1) * segmentStep) + 1
                        local nextIndex = math.min(pointIndex + 1, pointCount)
                        
                        if pointIndex <= pointCount and nextIndex <= pointCount then
                            local current = trajectoryPoints[pointIndex]
                            local next = trajectoryPoints[nextIndex]
                            local currentPos, nextPos = current[1], next[1]
                            
                            local midpoint = (currentPos + nextPos) * 0.5
                            local distance = (nextPos - currentPos).Magnitude
                            
                            if distance > 0.01 then
                                local direction = (nextPos - currentPos) / distance
                                
                                segments[i].Size = Vector3.new(0.3, 0.3, distance)
                                segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                                segments[i].Transparency = config.segmentTransparency
                            else
                                segments[i].Transparency = 1
                            end
                        else
                            segments[i].Transparency = 1
                        end
                    end
                else
                    for i = 1, config.segmentCount do
                        segments[i].Transparency = 1
                    end
                end
                
                local landingPos, landingVel = findFirstLanding(trajectoryPoints, pointCount)
                lastLandingPos = landingPos
                lastLandingVel = landingVel
                
                if landingPos then
                    local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                    landingMarker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingMarker.Transparency = 0.4
                    
                    local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                    landingRing.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                    landingRing.Transparency = 0.6
                    
                    local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                    local scale = 6 + pulse
                    landingRing.Size = Vector3.new(scale, 0.1, scale)
                else
                    landingMarker.Transparency = 1
                    landingRing.Transparency = 1
                end
            end)
        else
            if predictionConnection then
                predictionConnection:Disconnect()
                predictionConnection = nil
            end
            
            if curveFolder then
                curveFolder:Destroy()
                curveFolder = nil
            end
        end
    end
})
CreateHitbox()
UpdateHitbox()

local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "user",
})

local PlayerSection = PlayerTab:Section({
    Title = "Soon."
})

local Dialog = Window:Dialog({
    Icon = "bird",
    Title = "Hey!",
    Content = "Report To Our Discord If You Found Bugs/Glitches",
    Buttons = {
        {
            Title = "Continue",
            Callback = function()
                CreateMainUI()
            end
        }
    }
})

WindUI:Notify({
    Title = "RSS Loaded",
    Icon = "check",
    Content = "Go Fuck RSS"
})
