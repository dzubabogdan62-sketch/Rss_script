-- ============================================
-- RSS - VETA –£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Ñ—É—Ç–±–æ–ª–∞ v3
-- ============================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- –ö–æ–Ω—Ñ–∏–≥–∏
local CONFIG = {
    DEFAULT_REACH = 10,
    MAX_REACH = 50,
    DIVE_DISTANCE = 10.3,
    DIVE_COOLDOWN = 0.7,
    BALL_NAMES = {"ball", "TPS", "PSoccerBall", "Ball", "SoccerBall"},
    GRAVITY = 196.2,
}

-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
local State = {
    IsReachEnabled = false,
    IsVisualizerEnabled = false,
    HitboxSize = Vector3.new(CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH, CONFIG.DEFAULT_REACH),
    ReachConnection = nil,
    RSSHitbox = nil,
    InfiniteStaminaEnabled = false,
}

getgenv().InfiniteStaminaEnabled = false

-- ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ============

local function Notify(title, content, icon)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = title,
            Text = content,
            Icon = icon == "check" and "rbxassetid://6031075938" or "rbxassetid://6031068426",
            Duration = 3,
        })
    end)
end

local function GetRoot()
    local character = LocalPlayer.Character
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
end

local function FindBall()
    for _, name in pairs(CONFIG.BALL_NAMES) do
        local ball = Workspace:FindFirstChild(name)
        if ball and ball:IsA("BasePart") then
            return ball
        end
        
        -- –ü–æ–∏—Å–∫ –≤ –ø–∞–ø–∫–∞—Ö
        for _, folder in pairs(Workspace:GetChildren()) do
            if folder:IsA("Folder") or folder:IsA("Model") then
                local foundBall = folder:FindFirstChild(name)
                if foundBall and foundBall:IsA("BasePart") then
                    return foundBall
                end
            end
        end
    end
    return nil
end

local function IsGoalkeeper()
    local character = LocalPlayer.Character
    if not character then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É
    if not LocalPlayer.Team then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–æ–ª—å —á–µ—Ä–µ–∑ GUI –∏–ª–∏ –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã
    pcall(function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 2)
        local roleGui = playerGui:FindFirstChild("Role") or playerGui:FindFirstChild("Position")
        if roleGui then
            local roleText = roleGui:FindFirstChildOfClass("TextLabel")
            if roleText and string.find(roleText.Text:lower(), "goal") then
                return true
            end
        end
    end)
    
    return true -- –í—Ä–µ–º–µ–Ω–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º true –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
end

-- ============ REACH –°–ò–°–¢–ï–ú–ê ============

local function CreateHitbox()
    if State.RSSHitbox then State.RSSHitbox:Destroy() end

    local root = GetRoot()
    if not root then return end

    State.RSSHitbox = Instance.new("BoxHandleAdornment")
    State.RSSHitbox.Name = "RSSHitbox"
    State.RSSHitbox.AlwaysOnTop = false
    State.RSSHitbox.ZIndex = 10
    State.RSSHitbox.Color3 = Color3.fromRGB(0, 255, 0)
    State.RSSHitbox.Transparency = 1
    State.RSSHitbox.Size = State.HitboxSize
    State.RSSHitbox.Adornee = root
    State.RSSHitbox.Parent = Workspace.Terrain

    local Glow = Instance.new("BoxHandleAdornment")
    Glow.Name = "Glow"
    Glow.AlwaysOnTop = true
    Glow.ZIndex = 0
    Glow.Color3 = Color3.fromRGB(0, 255, 100)
    Glow.Transparency = 1
    Glow.Size = State.HitboxSize
    Glow.Parent = State.RSSHitbox
end

local function UpdateHitbox()
    if not State.RSSHitbox then CreateHitbox() return end
    
    State.RSSHitbox.Size = State.HitboxSize
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then 
        Glow.Size = State.HitboxSize
        Glow.Transparency = (State.IsReachEnabled and State.IsVisualizerEnabled) and 0.7 or 1
    end
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not State.RSSHitbox then return end

    State.RSSHitbox.Adornee = root
    local Glow = State.RSSHitbox:FindFirstChild("Glow")
    if Glow then Glow.Adornee = root end

    local ball = FindBall()
    if not ball then return end

    local effectiveReach = math.max(State.HitboxSize.X, State.HitboxSize.Y, State.HitboxSize.Z) / 2

    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        local character = LocalPlayer.Character
        if character then
            for _, part in character:GetChildren() do
                if part:IsA("BasePart") then
                    pcall(function()
                        firetouchinterest(part, ball, 0)
                        task.wait()
                        firetouchinterest(part, ball, 1)
                    end)
                end
            end
        end
    end
end

local function EnableReach()
    if State.ReachConnection then return end
    State.IsReachEnabled = true
    CreateHitbox()
    UpdateHitbox()
    State.ReachConnection = RunService.Heartbeat:Connect(ReachLoop)
    Notify("Reach", "Reach –≤–∫–ª—é—á–µ–Ω ‚úì", "check")
end

local function DisableReach()
    if State.ReachConnection then 
        State.ReachConnection:Disconnect() 
        State.ReachConnection = nil 
    end
    State.IsReachEnabled = false
    UpdateHitbox()
    Notify("Reach", "Reach –≤—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
end
-- ============ STAMINA –°–ò–°–¢–ï–ú–ê ============

local speeds = nil
local defaultWalk = 16

local function SetupStamina()
    pcall(function()
        local gui = LocalPlayer:WaitForChild("PlayerGui", 10)
        local stamina = gui:WaitForChild("Stamina", 10)
        local frame = stamina:WaitForChild("Frame", 5)
        speeds = frame:WaitForChild("Speeds", 5)
        defaultWalk = speeds.Walk.Value
    end)
end

local function UpdateStamina()
    if speeds then
        speeds.Walk.Value = State.InfiniteStaminaEnabled and speeds.Run.Value or defaultWalk
    end
end

SetupStamina()
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    SetupStamina()
    UpdateStamina()
    if State.IsReachEnabled then
        CreateHitbox()
    end
end)

-- ============ UI –ó–ê–ì–†–£–ó–ö–ê ============

local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA v3",
    Icon = "rbxassetid://106211849494703",
    Author = "–£–ª—É—á—à–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç —Å —Ñ–∏–∫—Å–∞–º–∏",
    Folder = "RSSVETA",
})

-- ============ MAIN TAB ============
local MainTab = Window:Tab({
    Title = "üéØ Reach",
    Icon = "target",
})

local ReachSection = MainTab:Section({
    Title = "–û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"
})

ReachSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Reach",
    Default = false,
    Callback = function(v)
        if v then EnableReach() else DisableReach() end
    end
})

ReachSection:Toggle({
    Title = "–ü–æ–∫–∞–∑–∞—Ç—å —Ö–∏—Ç–±–æ–∫—Å",
    Default = false,
    Callback = function(v)
        State.IsVisualizerEnabled = v
        UpdateHitbox()
    end
})

MainTab:Space()

local SizeSection = MainTab:Section({
    Title = "–†–∞–∑–º–µ—Ä—ã —Ö–∏—Ç–±–æ–∫—Å–∞ (X/Y/Z)"
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä X",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(v, State.HitboxSize.Y, State.HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä Y",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(State.HitboxSize.X, v, State.HitboxSize.Z)
        UpdateHitbox()
    end
})

SizeSection:Slider({
    Title = "–†–∞–∑–º–µ—Ä Z",
    Step = 1,
    Value = {Min = 1, Max = CONFIG.MAX_REACH, Default = CONFIG.DEFAULT_REACH},
    Callback = function(v)
        State.HitboxSize = Vector3.new(State.HitboxSize.X, State.HitboxSize.Y, v)
        UpdateHitbox()
    end
})

-- ============ GK TAB ============
local GkTab = Window:Tab({
    Title = "ü•Ö GK",
    Icon = "rbxassetid://10734950020"
})

local function IsInFansTeam()
    return LocalPlayer.Team and LocalPlayer.Team.Name == "Fans"
end

local function ChangeTeam(teamColor, position)
    if not IsInFansTeam() then
        Notify("–û—à–∏–±–∫–∞", "–¢—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ Fans!", "ban")
        return
    end
    
    pcall(function()
        local args = {teamColor, position}
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        task.wait(0.5)
        Notify("–£—Å–ø–µ—Ö", "–¢—ã —Ç–µ–ø–µ—Ä—å " .. position, "check")
    end)
end

local TeamSection = GkTab:Section({
    Title = "–í—ã–±–æ—Ä –∫–æ–º–∞–Ω–¥—ã"
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Home GK",
    Callback = function()
        ChangeTeam(BrickColor.new(23), "Goalie")
    end
})

TeamSection:Button({
    Title = "–í—ã–±—Ä–∞—Ç—å Away GK",
    Callback = function()
        ChangeTeam(BrickColor.new(141), "Goalie")
    end
})

GkTab:Space()

-- ============ –£–õ–£–ß–®–ï–ù–ù–ê–Ø AUTO DIVE –°–ò–°–¢–ï–ú–ê ============

local DiveState = {
    Enabled = false,
    Connection = nil,
    LastDiveTime = 0,
    DiveButtons = nil,
    ButtonSearchAttempts = 0,
}

local DIVE_CONFIG = {
    BASE_DISTANCE = 15,
    MAX_DISTANCE = 25,
    DIVE_COOLDOWN = 0.6,
    REACTION_TIME = 0.1,
    BALL_VELOCITY_THRESHOLD = 8,
    ANTICIPATION = 0.2,
    MAX_SEARCH_ATTEMPTS = 5,
}

-- –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Ç–∏ –ø–æ–∏—Å–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–∞–π–≤–∞
local DIVE_BUTTON_PATHS = {
    -- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—É—Ç—å
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local mobileCTRL = playerGui:WaitForChild("MobileCTRL", 3)
        local touchControlFrame = mobileCTRL:WaitForChild("TouchControlFrame", 3)
        local jumpButton = touchControlFrame:WaitForChild("JumpButton", 3)
        return {
            left = jumpButton:WaitForChild("LeftDive", 2),
            right = jumpButton:WaitForChild("RightDive", 2)
        }
    end,
    
    -- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å 1
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local controls = playerGui:FindFirstChild("Controls") or playerGui:FindFirstChild("TouchGui")
        if controls then
            local leftDive = controls:FindFirstChild("LeftDive", true)
            local rightDive = controls:FindFirstChild("RightDive", true)
            if leftDive and rightDive then
                return {left = leftDive, right = rightDive}
            end
        end
        return nil
    end,
    
    -- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å 2 - –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º—É PlayerGui
    function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui", 3)
        local leftDive = nil
        local rightDive = nil
        
        local function searchRecursive(parent)
            for _, child in pairs(parent:GetChildren()) do
                if child.Name == "LeftDive" and child:IsA("GuiButton") then
                    leftDive = child
                elseif child.Name == "RightDive" and child:IsA("GuiButton") then
                    rightDive = child
                end
                
                if child:IsA("GuiObject") then
                    searchRecursive(child)
                end
            end
        end
        
        searchRecursive(playerGui)
        
        if leftDive and rightDive then
            return {left = leftDive, right = rightDive}
        end
        return nil
    end,
    
    -- –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ UserInputService (–∫–ª–∞–≤–∏—à–∏)
    function()
        return {
            left = "Q", -- –û–±—ã—á–Ω–æ –ª–µ–≤—ã–π –¥–∞–π–≤ –Ω–∞ Q
            right = "E" -- –û–±—ã—á–Ω–æ –ø—Ä–∞–≤—ã–π –¥–∞–π–≤ –Ω–∞ E
        }
    end
}

local function FindDiveButtons()
    for i, searchFunc in ipairs(DIVE_BUTTON_PATHS) do
        local success, result = pcall(searchFunc)
        if success and result then
            print("–ù–∞–π–¥–µ–Ω—ã –∫–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞ –º–µ—Ç–æ–¥–æ–º", i)
            return result, i
        end
    end
    return nil, 0
end

local function FireDiveAction(action, method)
    if method <= 3 then
        -- GUI –∫–Ω–æ–ø–∫–∏
        if action and action.Parent then
            pcall(function()
                local connections = getconnections(action.MouseButton1Click)
                if connections and #connections > 0 then
                    connections[1]:Fire()
                else
                    action.MouseButton1Click:Fire()
                end
            end)
        end
    else
        -- –ö–ª–∞–≤–∏—à–∏
        if typeof(action) == "string" then
            pcall(function()
                local VirtualInputManager = game:GetService("VirtualInputManager")
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[action], false, game)
                task.wait(0.05)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[action], false, game)
            end)
        end
    end
end

local DiveSection = GkTab:Section({
    Title = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Dive [–ò–°–ü–†–ê–í–õ–ï–ù]"
})

DiveSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Smart Auto Dive",
    Default = false,
    Callback = function(enabled)
        if not enabled then
            DiveState.Enabled = false
            if DiveState.Connection then
                DiveState.Connection:Disconnect()
                DiveState.Connection = nil
            end
            Notify("Auto Dive", "–í—ã–∫–ª—é—á–µ–Ω ‚úó", "ban")
            return
        end
        
        DiveState.Enabled = true
        
        -- –ü–æ–∏—Å–∫ –∫–Ω–æ–ø–æ–∫ –¥–∞–π–≤–∞
        local buttons, method = FindDiveButtons()
        if not buttons then
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!", "ban")
            DiveState.Enabled = false
            return
        end
        
        DiveState.DiveButtons = buttons
        DiveState.ButtonMethod = method
        
        local lastBallPos = nil
        local ballVelocity = Vector3.zero
        
        if DiveState.Connection then
            DiveState.Connection:Disconnect()
        end
        
        DiveState.Connection = RunService.Heartbeat:Connect(function()
            if not DiveState.Enabled then return end
            
            local character = LocalPlayer.Character
            local root = GetRoot()
            if not character or not root then return end
            
            local ball = FindBall()
            if not ball then return end
            
            pcall(function()
                local ballPos = ball.Position
                local playerPos = root.Position
                local distance = (ballPos - playerPos).Magnitude
                local currentTime = tick()
                
                -- –†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –º—è—á–∞
                if lastBallPos then
                    ballVelocity = (ballPos - lastBallPos) * 60
                end
                lastBallPos = ballPos
                
                local ballSpeed = ballVelocity.Magnitude
                
                -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–≤–∏–∂–µ—Ç—Å—è –ª–∏ –º—è—á –∫ –Ω–∞–º
                local ballDirection = ballVelocity.Unit
                local toPlayer = (playerPos - ballPos).Unit
                local approachingFactor = ballDirection:Dot(toPlayer)
                
                -- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏
                local dynamicDiveDistance = DIVE_CONFIG.BASE_DISTANCE
                if ballSpeed > DIVE_CONFIG.BALL_VELOCITY_THRESHOLD then
                    dynamicDiveDistance = math.min(
                        DIVE_CONFIG.BASE_DISTANCE + (ballSpeed - DIVE_CONFIG.BALL_VELOCITY_THRESHOLD) * 0.3,
                        DIVE_CONFIG.MAX_DISTANCE
                    )
                end
                
                -- –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º—è—á–∞
                local predictedBallPos = ballPos + (ballVelocity * DIVE_CONFIG.ANTICIPATION)
                local predictedDistance = (predictedBallPos - playerPos).Magnitude
                
                -- –£—Å–ª–æ–≤–∏—è –¥–ª—è dive
                local shouldDive = (distance <= dynamicDiveDistance or predictedDistance <= dynamicDiveDistance) and
                                   (currentTime - DiveState.LastDiveTime) >= DIVE_CONFIG.DIVE_COOLDOWN and
                                   ballSpeed > DIVE_CONFIG.BALL_VELOCITY_THRESHOLD and
                                   approachingFactor > 0.3 -- –ú—è—á –¥–≤–∏–∂–µ—Ç—Å—è –∫ –Ω–∞–º
                
                if shouldDive then
                    local targetPos = predictedDistance <= dynamicDiveDistance and predictedBallPos or ballPos
                    local localBallPos = root.CFrame:PointToObjectSpace(targetPos)
                    
                    -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ dive —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
                    local diveAction = nil
                    if math.abs(localBallPos.X) > 1 then
                        diveAction = localBallPos.X < 0 and DiveState.DiveButtons.left or DiveState.DiveButtons.right
                    else
                        -- –ï—Å–ª–∏ –º—è—á –ø–æ —Ü–µ–Ω—Ç—Ä—É, –≤—ã–±–∏—Ä–∞–µ–º —Å—Ç–æ—Ä–æ–Ω—É –ø–æ Z –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ
                        diveAction = localBallPos.Z > 0 and DiveState.DiveButtons.right or DiveState.DiveButtons.left
                    end
                    
                    if diveAction then
                        FireDiveAction(diveAction, DiveState.ButtonMethod)
                        DiveState.LastDiveTime = currentTime
                        
                        -- –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
                        local side = diveAction == DiveState.DiveButtons.left and "–õ–µ–≤—ã–π" or "–ü—Ä–∞–≤—ã–π"
                        print("–î–∞–π–≤:", side, "| –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ:", math.floor(distance), "| –°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞:", math.floor(ballSpeed))
                    end
                end
            end)
        end)
        
        local methodName = method <= 3 and "GUI –∫–Ω–æ–ø–∫–∏" or "–ö–ª–∞–≤–∏—à–∏"
        Notify("Auto Dive", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (" .. methodName .. ") ‚úì", "check")
    end
})

DiveSection:Slider({
    Title = "–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ª–æ–≤–∫–∏",
    Step = 0.5,
    Value = {Min = 8, Max = 30, Default = 15},
    Callback = function(v)
        DIVE_CONFIG.BASE_DISTANCE = v
    end
})

DiveSection:Slider({
    Title = "–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ–∞–∫—Ü–∏–∏",
    Step = 0.05,
    Value = {Min = 0.2, Max = 1.0, Default = 0.6},
    Callback = function(v)
        DIVE_CONFIG.DIVE_COOLDOWN = v
    end
})

DiveSection:Slider({
    Title = "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞",
    Step = 1,
    Value = {Min = 3, Max = 20, Default = 8},
    Callback = function(v)
        DIVE_CONFIG.BALL_VELOCITY_THRESHOLD = v
    end
})

-- –ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–π–≤–∞
DiveSection:Button({
    Title = "–¢–µ—Å—Ç –ª–µ–≤–æ–≥–æ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            FireDiveAction(buttons.left, method)
            Notify("–¢–µ—Å—Ç", "–õ–µ–≤—ã–π –¥–∞–π–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω", "check")
        else
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "ban")
        end
    end
})

DiveSection:Button({
    Title = "–¢–µ—Å—Ç –ø—Ä–∞–≤–æ–≥–æ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            FireDiveAction(buttons.right, method)
            Notify("–¢–µ—Å—Ç", "–ü—Ä–∞–≤—ã–π –¥–∞–π–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω", "check")
        else
            Notify("–û—à–∏–±–∫–∞", "–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "ban")
        end
    end
})
-- ============ STAMINA TAB ============
local StaminaTab = Window:Tab({
    Title = "‚ö° Stamina",
    Icon = "zap",
})

local StaminaSection = StaminaTab:Section({
    Title = "–ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å"
})

StaminaSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Infinite Stamina",
    Default = false,
    Callback = function(v)
        State.InfiniteStaminaEnabled = v
        getgenv().InfiniteStaminaEnabled = v
        UpdateStamina()
        Notify("Stamina", v and "–í–∫–ª—é—á–µ–Ω–∞ ‚úì" or "–í—ã–∫–ª—é—á–µ–Ω–∞ ‚úó", v and "check" or "ban")
    end
})

-- ============ BALL PREDICTOR ============

local PredictTab = Window:Tab({
    Title = "üé± Ball Predictor",
    Icon = "circle",
})

local PredictionState = {
    Enabled = false,
    Connection = nil,
    CurveFolder = nil,
}

local PREDICT_CONFIG = {
    gravity = 196.2,
    bounceDamping = 0.68,
    groundHeight = 0,
    minBounceVelocity = 8,
    airResistance = 0.99,
    frictionCoefficient = 0.85,
    terminalVelocity = 200,
    segmentCount = 25,
    segmentSize = Vector3.new(0.3, 0.3, 2),
    maxPredictionTime = 10,
    minVelocityThreshold = 3,
    updateRate = 3,
    colorCurve = Color3.fromRGB(0, 255, 0),
    colorLanding = Color3.fromRGB(255, 255, 0),
}

local function CreatePredictorSegments()
    if PredictionState.CurveFolder then
        PredictionState.CurveFolder:Destroy()
    end
    
    PredictionState.CurveFolder = Instance.new("Folder")
    PredictionState.CurveFolder.Name = "BallPredictionCurve"
    PredictionState.CurveFolder.Parent = Workspace
    
    local segments = {}
    for i = 1, PREDICT_CONFIG.segmentCount do
        local segment = Instance.new("Part")
        segment.Name = "Segment_" .. i
        segment.Anchored = true
        segment.CanCollide = false
        segment.CastShadow = false
        segment.Material = Enum.Material.Neon
        segment.Transparency = 0.2
        segment.Size = PREDICT_CONFIG.segmentSize
        segment.Color = PREDICT_CONFIG.colorCurve
        segment.Parent = PredictionState.CurveFolder
        segments[i] = segment
    end
    
    -- –ú–∞—Ä–∫–µ—Ä—ã –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è
    local marker = Instance.new("Part")
    marker.Name = "LandingMarker"
    marker.Anchored = true
    marker.CanCollide = false
    marker.CastShadow = false
    marker.Material = Enum.Material.Neon
    marker.Color = PREDICT_CONFIG.colorLanding
    marker.Transparency = 0.4
    marker.Size = Vector3.new(4, 0.2, 4)
    marker.Shape = Enum.PartType.Cylinder
    marker.Parent = PredictionState.CurveFolder
    
    local ring = Instance.new("Part")
    ring.Name = "LandingRing"
    ring.Anchored = true
    ring.CanCollide = false
    ring.CastShadow = false
    ring.Material = Enum.Material.Neon
    ring.Color = PREDICT_CONFIG.colorLanding
    ring.Transparency = 0.6
    ring.Size = Vector3.new(6, 0.1, 6)
    ring.Shape = Enum.PartType.Cylinder
    ring.Parent = PredictionState.CurveFolder
    
    return segments, marker, ring
end

local function SimulateTrajectory(startPos, startVel)
    local points = {}
    local gravityVector = Vector3.new(0, -PREDICT_CONFIG.gravity, 0)
    
    local pos = startPos
    local vel = startVel
    local time = 0
    local bounceCount = 0
    local pointCount = 0
    
    local dt = 0.033
    local gravityDt = gravityVector * dt
    local airResistance = PREDICT_CONFIG.airResistance ^ dt
    
    while time < PREDICT_CONFIG.maxPredictionTime and bounceCount < 8 and pointCount < 80 do
        time = time + dt
        pointCount = pointCount + 1
        
        vel = (vel + gravityDt) * airResistance
        
        if vel.Y < -PREDICT_CONFIG.terminalVelocity then
            vel = Vector3.new(vel.X, -PREDICT_CONFIG.terminalVelocity, vel.Z)
        end
        
        pos = pos + vel * dt
        points[pointCount] = {pos, vel}
        
        if pos.Y <= PREDICT_CONFIG.groundHeight and vel.Y < 0 then
            pos = Vector3.new(pos.X, PREDICT_CONFIG.groundHeight, pos.Z)
            
            local bounceVelY = -vel.Y * PREDICT_CONFIG.bounceDamping
            vel = Vector3.new(
                vel.X * PREDICT_CONFIG.frictionCoefficient,
                bounceVelY,
                vel.Z * PREDICT_CONFIG.frictionCoefficient
            )
            
            bounceCount = bounceCount + 1
            
            if vel.Magnitude < PREDICT_CONFIG.minBounceVelocity then
                break
            end
        end
        
        if pos.Y < -500 or vel.Magnitude < 0.3 then
            break
        end
    end
    
    return points, pointCount
end

local PredictSection = PredictTab:Section({
    Title = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞"
})

PredictSection:Toggle({
    Title = "–í–∫–ª—é—á–∏—Ç—å Ball Predictor",
    Default = false,
    Callback = function(enabled)
        PredictionState.Enabled = enabled
        
        if not enabled then
            if PredictionState.Connection then
                PredictionState.Connection:Disconnect()
                PredictionState.Connection = nil
            end
            if PredictionState.CurveFolder then
                PredictionState.CurveFolder:Destroy()
                PredictionState.CurveFolder = nil
            end
            Notify("Ball Predictor", "–í—ã–∫–ª—é—á–µ–Ω", "ban")
            return
        end
        
        local segments, marker, ring = CreatePredictorSegments()
        local frameCounter = 0
        
        if PredictionState.Connection then
            PredictionState.Connection:Disconnect()
        end
        
        PredictionState.Connection = RunService.Heartbeat:Connect(function()
            frameCounter = frameCounter + 1
            
            if frameCounter % PREDICT_CONFIG.updateRate ~= 0 then
                return
            end
            
            local ball = FindBall()
            if not ball or not PredictionState.Enabled then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local velocity = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
            if velocity.Magnitude < PREDICT_CONFIG.minVelocityThreshold then
                for i = 1, PREDICT_CONFIG.segmentCount do
                    if segments[i] then segments[i].Transparency = 1 end
                end
                marker.Transparency = 1
                ring.Transparency = 1
                return
            end
            
            local points, pointCount = SimulateTrajectory(ball.Position, velocity)
            
            if pointCount > 1 then
                local segmentStep = math.max(1, (pointCount - 1) / (PREDICT_CONFIG.segmentCount - 1))
                
                for i = 1, PREDICT_CONFIG.segmentCount do
                    local pointIndex = math.min(math.floor((i - 1) * segmentStep) + 1, pointCount)
                    local nextIndex = math.min(pointIndex + 1, pointCount)
                    
                    if segments[i] and pointIndex <= pointCount and points[pointIndex] then
                        local currentPos = points[pointIndex][1]
                        local nextPos = points[nextIndex] and points[nextIndex][1] or currentPos
                        local midpoint = (currentPos + nextPos) * 0.5
                        local distance = (nextPos - currentPos).Magnitude
                        
                        if distance > 0.01 then
                            local direction = (nextPos - currentPos) / distance
                            segments[i].Size = Vector3.new(0.3, 0.3, math.max(0.1, distance))
                            segments[i].CFrame = CFrame.lookAt(midpoint, midpoint + direction)
                            segments[i].Transparency = 0.2
                        else
                            segments[i].Position = currentPos
                            segments[i].Transparency = 0.2
                        end
                    end
                end
                
                -- –ù–∞–π—Ç–∏ –ø–µ—Ä–≤–æ–µ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏–µ
                for i = 2, pointCount do
                    if points[i] and points[i-1] and 
                       points[i][1].Y <= PREDICT_CONFIG.groundHeight and 
                       points[i-1][1].Y > PREDICT_CONFIG.groundHeight then
                        
                        local landingPos = points[i][1]
                        local markerPos = landingPos + Vector3.new(0, 0.1, 0)
                        marker.CFrame = CFrame.new(markerPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        marker.Transparency = 0.4
                        
                        local ringPos = landingPos + Vector3.new(0, 0.05, 0)
                        ring.CFrame = CFrame.new(ringPos) * CFrame.Angles(0, 0, math.pi * 0.5)
                        ring.Transparency = 0.6
                        
                        local pulse = math.sin(tick() * 5) * 0.5 + 0.5
                        ring.Size = Vector3.new(6 + pulse, 0.1, 6 + pulse)
                        break
                    end
                end
            end
        end)
        
        Notify("Ball Predictor", "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω", "check")
    end
})

-- ============ –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ============

local SettingsTab = Window:Tab({
    Title = "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    Icon = "settings",
})

local InfoSection = SettingsTab:Section({
    Title = "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∫—Ä–∏–ø—Ç–µ"
})

InfoSection:Button({
    Title = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –º—è—á–∞",
    Callback = function()
        local ball = FindBall()
        if ball then
            local velocity = ball.AssemblyLinearVelocity or ball.Velocity or Vector3.zero
            Notify("–ú—è—á –Ω–∞–π–¥–µ–Ω", "–°–∫–æ—Ä–æ—Å—Ç—å: " .. math.floor(velocity.Magnitude), "check")
        else
            Notify("–ú—è—á –Ω–µ –Ω–∞–π–¥–µ–Ω", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–≥—Ä—É", "ban")
        end
    end
})

InfoSection:Button({
    Title = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–æ–ª—å –∏–≥—Ä–æ–∫–∞",
    Callback = function()
        local isGK = IsGoalkeeper()
        local team = LocalPlayer.Team and LocalPlayer.Team.Name or "–ù–µ—Ç –∫–æ–º–∞–Ω–¥—ã"
        Notify("–†–æ–ª—å", "–ö–æ–º–∞–Ω–¥–∞: " .. team .. " | GK: " .. (isGK and "–î–∞" or "–ù–µ—Ç"), "check")
    end
})

InfoSection:Button({
    Title = "–ù–∞–π—Ç–∏ –∫–Ω–æ–ø–∫–∏ –¥–∞–π–≤–∞",
    Callback = function()
        local buttons, method = FindDiveButtons()
        if buttons then
            local methodNames = {"–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—É—Ç—å", "–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π 1", "–ü–æ–∏—Å–∫ –ø–æ GUI", "–ö–ª–∞–≤–∏—à–∏"}
            Notify("–ö–Ω–æ–ø–∫–∏ –Ω–∞–π–¥–µ–Ω—ã", methodNames[method] or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–µ—Ç–æ–¥", "check")
        else
            Notify("–ö–Ω–æ–ø–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é –∏–≥—Ä—É", "ban")
        end
    end
})

-- ============ –ó–ê–í–ï–†–®–ï–ù–ò–ï ============

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
CreateHitbox()
UpdateHitbox()

-- –î–∏–∞–ª–æ–≥ –∑–∞–≥—Ä—É–∑–∫–∏
local Dialog = Window:Dialog({
    Icon = "star",
    Title = "RSS - VETA v3 ‚úì",
    Content = "–°–∫—Ä–∏–ø—Ç —É–ª—É—á—à–µ–Ω –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω!\n\n‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –∞–≤—Ç–æ-–ø—Ä—ã–∂–∫–∏\n‚úÖ –£–ª—É—á—à–µ–Ω –ø–æ–∏—Å–∫ –∫–Ω–æ–ø–æ–∫\n‚úÖ –î–æ–±–∞–≤–ª–µ–Ω—ã —Ç–µ—Å—Ç—ã\n‚úÖ –õ—É—á—à–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫",
    Buttons = {
        {
            Title = "–ü–æ–Ω—è—Ç–Ω–æ",
            Callback = function()
                Notify("RSS v3", "–°–∫—Ä–∏–ø—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!", "check")
            end
        }
    }
})

print("RSS - VETA v3 –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
print("–û—Å–Ω–æ–≤–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:")
print("- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ-–¥–∞–π–≤–∞")
print("- –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –ø–æ–∏—Å–∫–∞ –∫–Ω–æ–ø–æ–∫")
print("- –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫")
print("- –î–æ–±–∞–≤–ª–µ–Ω—ã —Ç–µ—Å—Ç—ã —Ñ—É–Ω–∫—Ü–∏–π")
print("- –õ—É—á—à–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å —Ä–∞–∑–Ω—ã–º–∏ –∏–≥—Ä–∞–º–∏")
